---
title: "Imputation"
author: "Remo Schmutz"
date: "2023-12-11"
output:
  html_document: 
    fig_caption: true
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

## TODO: Finish imputation for South Africa

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
data <- readRDS("../../data_clean/art_noTB.rds")
library(mice)
library(gridExtra)
library(tidyverse)
library(lattice)
library(kableExtra)
library(tableone)
```

This document serves as a broad overview of the theory and implementation of the Multiple iterative chained equations (MICE) as I understand it. This should help me learn the theory behind the method and makes it easier for you to make nuanced improvements to my implementation and give further advice to improve the prediction.

# Method: Multiple iterative chained equations (MICE)

-   The main idea is to use an iterative approach to predict the missing values in the dataset using the existing data.

-   To make it more illustrative, I will define the dataset as $M$, including the columns $A, B$ and $C$.

Iteration 1:

1.  We use the median of each column to fill the missing values in the respective column. The matrix $M$ is now full and exists of the true values and the median (per column) of the true values.
2.  Assume column $A$ has missing values in it. Delete every row where there were originally missing values in column $A$. Build a model predicting column $A$ from the other columns. $A$ \~ $B + C$. Which exact model is used can be defined with the parameter `method`.
3.  This model is then used to predict the missing values in column $A$. Note, imputed median values for the other columns were used in the learning phase. I.e. if we want to predict $A_1$ but $B_1$ was originally also missing. The imputed $B_1$ (i.e. median of $B$) is used nevertheless.
4.  This is then repeated for every column.

Iteration i $\in \{2,k\}$:

1.  Repeat the algorithm from iteration 1, the difference: In the case that predictors were originally also missing, they are now not replaced by the median of their respective column, but with the prediction of the model in iteration $i-1$.

Pool the estimates from each model into a single set of estimates.

# Implementation:

1.  Inspect the missing data pattern with `md.pattern(df)`.

2.  Fit the imputation `imp <- mice(df)`.

3.  Changing prediction matrix with `imp$pred`, if there are certain predictor that should be excluded.

4.  Change the imputation method by `imp$meth` , using predictive mean matching "pmm" for continous outcomes and logistic regression "logreg" for binary outcomes seem to be the norm. I would probably use proportional odds logistig regression "polr" for ordinal data like `who_stage`.

5.  Use `stripplot(imp, col~.imp, pch=20, cex=2)` to compare the imputed values for column `col` with the existing data. When missing completely at random (MCAR) assumption is met, these should have the same distribution.

6.  Perform the analysis on each imputed dataset.

7.  Pool the analysis and inspect the pooled analysis.

## Data

```{r echo=FALSE, message=FALSE, warning=FALSE, pattern}
library(patchwork)
library(GGally)
library(finalfit)

## select variables ----

df <- data %>% 
  rename("sex" = gender, 
         "age" = age_at_art_start,
         "bcd4" = cd4_baseline,
         "brna" = rna_baseline,
         "who" = who_stage,
         "regio" = region,
         "pres_tb" = presenting_tb) %>%
  mutate(bcd4_tr = sqrt(bcd4),
         brna_tr = log10(brna + 1),
         regimen = as.factor(regimen)) %>% 
  select(sex, age, regio, bcd4, bcd4_tr, brna, brna_tr, who, regimen, incident_tb, cohort)

df_ch <- df %>% filter(cohort == "CH") %>%
  select(-cohort)

df_ch$regio <- relevel(df_ch$regio, ref = "Europe")

df_rsa <- df %>% filter(cohort == "RSA") %>% 
  select(-cohort)
```

## Complete records analysis (logistic regression)

### Switzerland

```{r, warning=F}
log_cr_ch <- glm(incident_tb ~ sex + age + who + regio +  bcd4_tr + brna_tr, 
                 family="binomial", 
                 data= df_ch)
summary(log_cr_ch)

#round(exp(cbind(coef(log_cr_ch), confint(log_cr_ch))), 3)
```

### South Africa

```{r}
log_cr_rna <- glm(incident_tb ~ sex + age + bcd4_tr, 
                 family="binomial", 
                 data= df_rsa)

summary(log_cr_rna)

#round(exp(cbind(coef(log_cr_rna), confint(log_cr_rna))), 3)
```

The complete record analysis is valid under the assumption of probability of complete record not associated with outcome (incidence of TB) given covariates.

## Investigate systematic missingness

```{r echo=TRUE}
data.to.impute_ch <- df_ch

data.to.impute_rsa <- df_rsa %>%
  select(-regio, - brna_tr, -brna, -who)

syst_miss <- function(df_ti, return) {
  
  #' the function prints the whole systematic missingness analysis and adds the incomplete column to
  #' the respective dataset for the glm
  
  data.to.impute <- df_ti
  
  data.to.impute$incomplete <- complete.cases(data.to.impute)
  
  vars <- names(data.to.impute)
  
  cts <- vars[sapply(data.to.impute, is.numeric)]
  
  cat <- vars[(!(vars %in% cts))]
  
  tablemiss <- CreateTableOne(vars = vars, 
                            strata="incomplete", 
                            data = data.to.impute, 
                            factorVars = cat, 
                            includeNA = F)
  
  if (return == "data") {
    return(data.to.impute)
  } else if (return == "table") {
    return(tablemiss)
  } else if (return == "md") {
    return(md.pattern(data.to.impute, rotate.names = T))
  }
    else {
    return(list(dataframe1 = data.to.impute, dataframe2 = tablemiss))
  }
  
}

```

### Switzerland

```{r}
data.to.impute_ch <- syst_miss(data.to.impute_ch, return = "data")
syst_miss(data.to.impute_ch, return = "table")
syst_miss(data.to.impute_ch, return = "md")

miss.mod_ch <- glm(incomplete ~ 
                     #sex +
                      age + 
                      regio + 
                     bcd4_tr + 
                     #bcd4 +
                     brna_tr + 
                     #brna +
                     # who + #complete seperation
                     #incident_tb +
                     regimen, 
                   family="binomial", 
                   data = data.to.impute_ch,
                   control = list(maxit = 50))

summary(miss.mod_ch)

data.to.impute_ch$incomplete <- NULL

#' significant effect for bcd4_tr, brna_tr, regimen
#' I will include those as predictors in the Imputation model
```

### South Africa 

```{r}
data.to.impute_rsa <- syst_miss(data.to.impute_rsa, return = "data")
syst_miss(data.to.impute_rsa, return = "table")
syst_miss(data.to.impute_rsa, return = "md") 

miss.mod_rsa <- glm(incomplete ~ 
                     sex +
                     age + 
                     bcd4_tr +
                     incident_tb +
                     #regimen +# does not converge when i include it
                    incident_tb, 
                   family="binomial", 
                   data = data.to.impute_rsa, 
                   control = list(maxit = 50))

summary(miss.mod_rsa)

data.to.impute_rsa$incomplete <- NULL
```

I exclude variables that are non-significant in the table. Also variables that have complete separation which leads to failure of the model fit. (there is possibly a solution for this)

## Imputation

### Switzerland

```{r}
pmat_ch <-matrix(
  c(0,0,0,0,0,0,0,0,0,0, # sex
    0,0,0,0,0,0,0,0,0,0, # age
    0,0,0,1,0,1,0,0,1,0, # regio
    0,0,0,0,0,1,0,0,1,0, # bcd4
    0,0,0,0,0,0,0,0,0,0, # bcd4_tr
    0,0,0,1,0,0,0,0,1,0, # brna
    0,0,0,0,0,0,0,0,0,0, # brna_tr
    0,0,0,1,0,1,0,0,1,0, # who
    0,0,0,1,0,1,0,0,0,0, # regimen
    0,0,0,0,0,0,0,0,0,0) #incident_tb
  ,nrow=10,byrow=T)

# The imputation command is then as follows. Notice how
# the "~I( )" is used to define the passive calculations.
# As these only work with numbers, we need to express our factor variables
# as integers.

K <- 15 # number of imputations

ch.imp <- mice(data = data.to.impute_ch,
               m = K,
               method=c(""
                        ,""
                        ,"polr"  # regio
                        ,"cart"  # bcd4, because wont work with "norm"
                        ,"~I(sqrt(bcd4))"#bcd4_tr
                        ,"pmm" #brna, pmm because we can prevent values < 0 
                        ,"~I(log10(brna + 1))" # brna_tr
                        ,"polr" # who
                        ,"polyreg" # regimen
                        ,"")
                 ,predictorMatrix = pmat_ch
                 ,seed=1569
                 ,maxit=20
                 )

# check imputations
summary(complete(ch.imp, 0)) # with missingness, index 0
summary(complete(ch.imp, 1)) # imputed index 1:K

plot(ch.imp)
```

### South Africa

```{r}
pmat_rsa <-matrix(
  c(0,0,0,0,0,0, # sex
    0,0,0,0,0,0, # age
    1,1,0,0,0,1, # bcd4
    0,0,0,0,0,0, # bcd4_tr
    1,1,1,0,0,1, # regimen
    0,0,0,0,0,0) # incident_tb
  ,nrow=6,byrow=T)

# The imputation command is then as follows. Notice how
# the "~I( )" is used to define the passive calculations.
# As these only work with numbers, we need to express our factor variables
# as integers.

K <- 15 # number of imputations

rsa.imp <- mice(data = data.to.impute_rsa,
               m = K,
               method=c("" #sex
                        ,"" #age
                        ,"pmm"  # bcd4_tr
                        ,"~I(sqrt(bcd4))"#bcd4_tr
                        ,"polyreg" #regimen
                        ,"" #incident_tb
                        )
                 ,predictorMatrix = pmat_rsa
                 ,seed=1569
                 ,maxit=20
                 )

# check imputations
summary(complete(rsa.imp, 0)) # with missingness, index 0
summary(complete(rsa.imp, 1)) # imputed index 1:K
```

## Fit model

```{r}
miceMCError <- function(pooledRes) {
  monteCarloSE <- sqrt(pooledRes$pooled$b/pooledRes$m)
  ciLower <- pooledRes$pooled$estimate - qt(0.975,df=pooledRes$m-1)*monteCarloSE
  ciUpper <- pooledRes$pooled$estimate + qt(0.975,df=pooledRes$m-1)*monteCarloSE
  mcTable <- cbind(pooledRes$pooled$estimate, monteCarloSE, ciLower, ciUpper)
  colnames(mcTable) <- c("Estimate", "Monte Carlo SE", "95% CI lower limit", "95% CI upper limit")
  print(mcTable)
  print("Warning: 95% CI only quantifies Monte-Carlo uncertainty!")
}
```

### Switzerland

```{r}
fit_ch_imp <- with(data = ch.imp, 
                  exp = glm(incident_tb ~ sex + age + who + regio + bcd4_tr + brna_tr,
                            family="binomial"))

pooled_ch <- pool(fit_ch_imp)
summary(pool(fit_ch_imp))
miceMCError(pooled_ch)
```

### South Africa

```{r}
fit_rsa_imp <- with(data = rsa.imp,
                    exp = glm(incident_tb ~ sex + age + bcd4_tr, 
                              family="binomial"))
pooled_rsa <- pool(fit_rsa_imp)
summary(pooled_rsa)
miceMCError(pooled_rsa)
```

