---
title: "Imputation"
author: "Remo Schmutz"
date: "2023-12-11"
output:
  html_document: 
    fig_caption: true
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
set.seed(432)
knitr::opts_chunk$set(echo = TRUE)
data <- readRDS("../../data_clean/art_noTB.rds")
library(mice)
library(gridExtra)
library(lattice)
library(kableExtra)
library(tableone)
library(tidyverse)
library(jtools)
```

This document serves as a broad overview of the theory and implementation of the Multiple iterative chained equations (MICE) as I understand it. This should help me learn the theory behind the method and makes it easier for you to make nuanced improvements to my implementation and give further advice to improve the prediction.

# Method: Multiple iterative chained equations (MICE)

-   The main idea is to use an iterative approach to predict the missing values in the dataset using the existing data.

-   To make it more illustrative, I will define the dataset as $M$, including the columns $A, B$ and $C$.

Iteration 1:

1.  We use the median of each column to fill the missing values in the respective column. The matrix $M$ is now full and exists of the true values and the median (per column) of the true values.
2.  Assume column $A$ has missing values in it. Delete every row where there were originally missing values in column $A$. Build a model predicting column $A$ from the other columns. $A$ \~ $B + C$. Which exact model is used can be defined with the parameter `method`.
3.  This model is then used to predict the missing values in column $A$. Note, imputed median values for the other columns were used in the learning phase. I.e. if we want to predict $A_1$ but $B_1$ was originally also missing. The imputed $B_1$ (i.e. median of $B$) is used nevertheless.
4.  This is then repeated for every column.

Iteration i $\in \{2,k\}$:

1.  Repeat the algorithm from iteration 1, the difference: In the case that predictors were originally also missing, they are now not replaced by the median of their respective column, but with the prediction of the model in iteration $i-1$.

Pool the estimates from each model into a single set of estimates.

# Implementation:

1.  Inspect the missing data pattern with `md.pattern(df)`.

2.  Fit the imputation `imp <- mice(df)`.

3.  Changing prediction matrix with `imp$pred`, if there are certain predictor that should be excluded.

4.  Change the imputation method by `imp$meth` , using predictive mean matching "pmm" for continous outcomes and logistic regression "logreg" for binary outcomes seem to be the norm. I would probably use proportional odds logistig regression "polr" for ordinal data like `who_stage`.

5.  Use `stripplot(imp, col~.imp, pch=20, cex=2)` to compare the imputed values for column `col` with the existing data. When missing completely at random (MCAR) assumption is met, these should have the same distribution.

6.  Perform the analysis on each imputed dataset.

7.  Pool the analysis and inspect the pooled analysis.

## Data

```{r echo=FALSE, message=FALSE, warning=FALSE, pattern}
library(patchwork)
library(GGally)
library(finalfit)

## select variables ----

df <- data %>% 
  rename("sex" = gender, 
         "age" = age_at_art_start,
         "bcd4" = cd4_baseline,
         "brna" = rna_baseline,
         "who" = who_stage,
         "regio" = region,
         "pres_tb" = presenting_tb) %>%
  mutate(bcd4_tr = sqrt(bcd4),
         brna_tr = log10(brna + 1),
         regimen = as.factor(regimen)) %>% 
  dplyr::select(sex, age, regio, bcd4, bcd4_tr, brna, brna_tr, who, regimen, incident_tb, cohort)

df_ch <- df %>% filter(cohort == "CH") %>%
  dplyr::select(-cohort) 

df_ch$regio <- relevel(df_ch$regio, ref = "Europe/Northern America")

df_rsa <- df %>% filter(cohort == "RSA") %>% 
  dplyr::select(-cohort)
```

## Complete records analysis (logistic regression)

### Switzerland

```{r, warning=F}
log_cr_ch <- glm(incident_tb ~ sex + age + who + regio +  bcd4_tr + brna_tr, 
                 family = "binomial", 
                 data= df_ch)
summ(log_cr_ch, exp = T)
```

### South Africa

```{r}
log_cr_rsa <- glm(incident_tb ~ sex + age + bcd4_tr, 
                 family="binomial", 
                 data= df_rsa)

summ(log_cr_rsa, exp = T)
```

The complete record analysis is valid under the assumption of probability of complete record not associated with outcome (incidence of TB) given covariates.

## Investigate systematic missingness

```{r echo=TRUE}
data.to.impute_ch <- df_ch %>% 
  dplyr::select(-bcd4, -brna)

data.to.impute_rsa <- df_rsa %>%
  dplyr::select(-regio, - brna_tr, -brna, -who, -bcd4)

syst_miss <- function(df_ti, return) {
  
  #' the function prints the whole systematic missingness analysis and adds the incomplete column to
  #' the respective dataset for the glm
  
  data.to.impute <- df_ti
  
  data.to.impute$incomplete <- complete.cases(data.to.impute)
  
  vars <- names(data.to.impute)
  
  cts <- vars[sapply(data.to.impute, is.numeric)]
  
  cat <- vars[(!(vars %in% cts))]
  
  tablemiss <- CreateTableOne(vars = vars, 
                            strata="incomplete", 
                            data = data.to.impute, 
                            factorVars = cat, 
                            includeNA = F)
  
  if (return == "data") {
    return(data.to.impute)
  } else if (return == "table") {
    return(tablemiss)
  } else if (return == "md") {
    return(md.pattern(data.to.impute, rotate.names = T))
  }
    else {
    return(list(dataframe1 = data.to.impute, dataframe2 = tablemiss))
  }
  
}

```

### Switzerland

```{r}
data.to.impute_ch <- syst_miss(data.to.impute_ch, return = "data")
syst_miss(data.to.impute_ch, return = "table")
syst_miss(data.to.impute_ch, return = "md")

miss.mod_ch <- glm(incomplete ~ 
                     sex +
                      age + 
                      regio + 
                     bcd4_tr + 
                     brna_tr + 
                     #who + 
                     #incident_tb +
                     regimen, 
                   family="binomial", 
                   data = data.to.impute_ch,
                   control = list(maxit = 50))

summ(miss.mod_ch, exp = T)

data.to.impute_ch$incomplete <- NULL
```

### South Africa

```{r}
data.to.impute_rsa <- syst_miss(data.to.impute_rsa, return = "data")
syst_miss(data.to.impute_rsa, return = "table")
syst_miss(data.to.impute_rsa, return = "md") 

miss.mod_rsa <- glm(incomplete ~ 
                     sex +
                     age + 
                     bcd4_tr +
                     incident_tb +
                     #regimen + # does not converge when i include it
                    incident_tb, 
                   family="binomial", 
                   data = data.to.impute_rsa, 
                   control = list(maxit = 50))

summ(miss.mod_rsa)

data.to.impute_rsa$incomplete <- NULL
```

I exclude variables that are non-significant in the table. Also variables that have complete separation which leads to failure of the model fit. (there is possibly a solution for this)

## Imputation

Here I include the variables that are significantly related to missingness in the previous model.

### Switzerland

```{r, cache=TRUE, include = FALSE}
# prediction matrix

pmat_ch <- matrix(
  c(0,1,1,1,1,1,1,0, # sex
    1,0,1,1,1,1,1,0, # age
    1,1,0,1,1,1,1,0, # regio
    1,1,1,0,1,1,1,0, # bcd4_tr
    1,1,1,1,0,1,1,0, # brna_tr
    1,1,1,1,1,0,1,0, # who
    1,1,1,1,1,1,0,0, # regimen
    1,1,1,1,1,1,1,0), #incident_tb
  nrow = 8,
  byrow = TRUE)

# shell imputation (for post processing)

ini_ch <- mice(data = data.to.impute_ch, 
            maxit = 0)
post_ch <- ini_ch$post
post_ch["bcd4_tr"] <- "imp[[j]][, i] <- squeeze(imp[[j]][, i], c(0, 50))"
post_ch["brna_tr"] <- "imp[[j]][, i] <- squeeze(imp[[j]][, i], c(0, 10))"

# imputation

K <- 20 # number of imputations

ch.imp <- mice(data = data.to.impute_ch,
               m = K,
               method = c("",
                          "",
                          "polyreg",  # regio
                          "norm",  # bcd4_tr
                          "norm", #brna_tr 
                          "logreg", # who
                          "polyreg", # regimen
                          ""), 
               predictorMatrix = pmat_ch,
               seed = 1569,
               maxit = 20,
               post = post_ch
              )
```

```{r}
# check imputations
summary(complete(ch.imp, 0)) # with missingness, index 0
summary(complete(ch.imp, 1)) # imputed index 1:K
plot(ch.imp)
```

### South Africa

```{r cache=TRUE, include=FALSE}
# prediction matrix

pmat_rsa <- matrix(
  c(0,1,1,1,1, # sex
    1,0,1,1,1, # age
    1,1,0,1,1, # bcd4_tr
    1,1,1,0,1, # regimen
    1,1,1,1,0), # incident_tb
  nrow = 5, 
  byrow = TRUE)

# shell imputation (for post processing)

ini_rsa <- mice(data = data.to.impute_rsa, 
            maxit = 0)
post_rsa <- ini_rsa$post
post_rsa["bcd4_tr"] <- "imp[[j]][, i] <- squeeze(imp[[j]][, i], c(0, 50))"

# imputation

K <- 20 # number of imputations

rsa.imp <- mice(data = data.to.impute_rsa,
               m = K,
               method = c("", #sex
                        "", #age
                        "norm",  # bcd4_tr
                        "polyreg", #regimen
                        ""), #incident_tb
               predictorMatrix = pmat_rsa,
               seed = 1569,
               maxit = 20,
               post = post_rsa)
```

```{r}
# check imputations
summary(complete(rsa.imp, 0)) # with missingness, index 0
summary(complete(rsa.imp, 1)) # imputed index 1:K
```

## Fit Model

### Switzerland

```{r}
fit_ch_imp <- with(data = ch.imp, 
                   exp = glm(incident_tb ~ 
                               sex + age + who + regio + bcd4_tr + brna_tr,
                             family = "binomial"))

fit_ch_imp |>
  pool() |>
  summary(conf.int = TRUE, exponentiate = TRUE) |>
  tibble::column_to_rownames("term") |>
  round(3)
```

Complete

```{r}
summ(log_cr_ch, exp = T)
```

### South Africa

```{r}
fit_rsa_imp <- with(data = rsa.imp,
                    exp = glm(incident_tb ~ sex + age + bcd4_tr, 
                              family="binomial"))

fit_rsa_imp |>
  pool() |>
  summary(conf.int = TRUE, exponentiate = TRUE) |>
  tibble::column_to_rownames("term") |>
  round(3)
```

Complete

```{r}
summ(log_cr_rsa, exp = T)
```

