---
title: "Imputation"
author: "Remo Schmutz"
date: "2023-12-11"
output:
  html_document: 
    fig_caption: true
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
set.seed(432)
knitr::opts_chunk$set(echo = TRUE)
data <- readRDS("../../data_clean/art_noTB.rds")
library(mice)
library(gridExtra)
library(tidyverse)
library(lattice)
library(kableExtra)
library(tableone)
```

This document serves as a broad overview of the theory and implementation of the Multiple iterative chained equations (MICE) as I understand it. This should help me learn the theory behind the method and makes it easier for you to make nuanced improvements to my implementation and give further advice to improve the prediction.

# Method: Multiple iterative chained equations (MICE)

-   The main idea is to use an iterative approach to predict the missing values in the dataset using the existing data.

-   To make it more illustrative, I will define the dataset as $M$, including the columns $A, B$ and $C$.

Iteration 1:

1.  We use the median of each column to fill the missing values in the respective column. The matrix $M$ is now full and exists of the true values and the median (per column) of the true values.
2.  Assume column $A$ has missing values in it. Delete every row where there were originally missing values in column $A$. Build a model predicting column $A$ from the other columns. $A$ \~ $B + C$. Which exact model is used can be defined with the parameter `method`.
3.  This model is then used to predict the missing values in column $A$. Note, imputed median values for the other columns were used in the learning phase. I.e. if we want to predict $A_1$ but $B_1$ was originally also missing. The imputed $B_1$ (i.e. median of $B$) is used nevertheless.
4.  This is then repeated for every column.

Iteration i $\in \{2,k\}$:

1.  Repeat the algorithm from iteration 1, the difference: In the case that predictors were originally also missing, they are now not replaced by the median of their respective column, but with the prediction of the model in iteration $i-1$.

Pool the estimates from each model into a single set of estimates.

# Implementation:

1.  Inspect the missing data pattern with `md.pattern(df)`.

2.  Fit the imputation `imp <- mice(df)`.

3.  Changing prediction matrix with `imp$pred`, if there are certain predictor that should be excluded.

4.  Change the imputation method by `imp$meth` , using predictive mean matching "pmm" for continous outcomes and logistic regression "logreg" for binary outcomes seem to be the norm. I would probably use proportional odds logistig regression "polr" for ordinal data like `who_stage`.

5.  Use `stripplot(imp, col~.imp, pch=20, cex=2)` to compare the imputed values for column `col` with the existing data. When missing completely at random (MCAR) assumption is met, these should have the same distribution.

6.  Perform the analysis on each imputed dataset.

7.  Pool the analysis and inspect the pooled analysis.

## Data

```{r echo=FALSE, message=FALSE, warning=FALSE, pattern}
library(patchwork)
library(GGally)
library(finalfit)

## select variables ----

df <- data %>% 
  rename("sex" = gender, 
         "age" = age_at_art_start,
         "bcd4" = cd4_baseline,
         "brna" = rna_baseline,
         "who" = who_stage,
         "regio" = region,
         "pres_tb" = presenting_tb) %>%
  mutate(bcd4_tr = sqrt(bcd4),
         brna_tr = log10(brna + 1),
         regimen = as.factor(regimen)) %>% 
  select(sex, age, regio, bcd4, bcd4_tr, brna, brna_tr, who, regimen, incident_tb, cohort)

df_ch <- df %>% filter(cohort == "CH") %>%
  select(-cohort)

df_ch$regio <- relevel(df_ch$regio, ref = "Europe")

df_rsa <- df %>% filter(cohort == "RSA") %>% 
  select(-cohort)
```

## Complete records analysis (logistic regression)

### Switzerland

```{r, warning=F}
log_cr_ch <- glm(incident_tb ~ sex + age + who + regio +  bcd4_tr + brna_tr, 
                 family="binomial", 
                 data= df_ch)
summary(log_cr_ch)

#round(exp(cbind(coef(log_cr_ch), confint(log_cr_ch))), 3)
```

### South Africa

```{r}
log_cr_rna <- glm(incident_tb ~ sex + age + bcd4_tr, 
                 family="binomial", 
                 data= df_rsa)

summary(log_cr_rna)

#round(exp(cbind(coef(log_cr_rna), confint(log_cr_rna))), 3)
```

The complete record analysis is valid under the assumption of probability of complete record not associated with outcome (incidence of TB) given covariates.

## Investigate systematic missingness

```{r echo=TRUE}
data.to.impute_ch <- df_ch

data.to.impute_rsa <- df_rsa %>%
  select(-regio, - brna_tr, -brna, -who)

syst_miss <- function(df_ti, return) {
  
  #' the function prints the whole systematic missingness analysis and adds the incomplete column to
  #' the respective dataset for the glm
  
  data.to.impute <- df_ti
  
  data.to.impute$incomplete <- complete.cases(data.to.impute)
  
  vars <- names(data.to.impute)
  
  cts <- vars[sapply(data.to.impute, is.numeric)]
  
  cat <- vars[(!(vars %in% cts))]
  
  tablemiss <- CreateTableOne(vars = vars, 
                            strata="incomplete", 
                            data = data.to.impute, 
                            factorVars = cat, 
                            includeNA = F)
  
  if (return == "data") {
    return(data.to.impute)
  } else if (return == "table") {
    return(tablemiss)
  } else if (return == "md") {
    return(md.pattern(data.to.impute, rotate.names = T))
  }
    else {
    return(list(dataframe1 = data.to.impute, dataframe2 = tablemiss))
  }
  
}

```

### Switzerland

```{r}
data.to.impute_ch <- syst_miss(data.to.impute_ch, return = "data")
syst_miss(data.to.impute_ch, return = "table")
syst_miss(data.to.impute_ch, return = "md")

miss.mod_ch <- glm(incomplete ~ 
                     #sex +
                      age + 
                      regio + 
                     bcd4_tr + 
                     #bcd4 +
                     brna_tr + 
                     #brna +
                     # who + #complete seperation
                     #incident_tb +
                     regimen, 
                   family="binomial", 
                   data = data.to.impute_ch,
                   control = list(maxit = 50))

summary(miss.mod_ch)

data.to.impute_ch$incomplete <- NULL

#' significant effect for bcd4_tr, brna_tr, regimen
#' I will include those as predictors in the Imputation model
```

### South Africa

```{r}
data.to.impute_rsa <- syst_miss(data.to.impute_rsa, return = "data")
syst_miss(data.to.impute_rsa, return = "table")
syst_miss(data.to.impute_rsa, return = "md") 

miss.mod_rsa <- glm(incomplete ~ 
                     sex +
                     age + 
                     bcd4_tr +
                     incident_tb +
                     #regimen +# does not converge when i include it
                    incident_tb, 
                   family="binomial", 
                   data = data.to.impute_rsa, 
                   control = list(maxit = 50))

summary(miss.mod_rsa)

data.to.impute_rsa$incomplete <- NULL
```

I exclude variables that are non-significant in the table. Also variables that have complete separation which leads to failure of the model fit. (there is possibly a solution for this)

## Imputation

Here I include the variables that are significantly related to missingness in the previous model.

### Switzerland

```{r}
pmat_ch <-matrix(
  c(0,0,0,0,0,0,0,0,0,0, # sex
    0,0,0,0,0,0,0,0,0,0, # age
    0,0,0,1,0,1,0,0,1,0, # regio
    0,0,0,0,0,1,0,0,1,0, # bcd4
    0,0,0,0,0,0,0,0,0,0, # bcd4_tr
    0,0,0,1,0,0,0,0,1,0, # brna
    0,0,0,0,0,0,0,0,0,0, # brna_tr
    0,0,0,1,0,1,0,0,1,0, # who
    0,0,0,1,0,1,0,0,0,0, # regimen
    0,0,0,0,0,0,0,0,0,0) #incident_tb
  ,nrow=10,byrow=T)

K <- 15 # number of imputations

ch.imp <- mice(data = data.to.impute_ch,
               m = K,
               method=c(""
                        ,""
                        ,"polr"  # regio
                        ,"cart"  # bcd4, because wont work with "norm"
                        ,"~I(sqrt(bcd4))"#bcd4_tr
                        ,"pmm" #brna, pmm because we can prevent values < 0 
                        ,"~I(log10(brna + 1))" # brna_tr
                        ,"polr" # who
                        ,"polyreg" # regimen
                        ,"")
                 ,predictorMatrix = pmat_ch
                 ,seed=1569
                 ,maxit=20
                 )

# check imputations
summary(complete(ch.imp, 0)) # with missingness, index 0
summary(complete(ch.imp, 1)) # imputed index 1:K

plot(ch.imp)
```

### South Africa

```{r}
pmat_rsa <-matrix(
  c(0,0,0,0,0,0, # sex
    0,0,0,0,0,0, # age
    1,1,0,0,0,1, # bcd4
    0,0,0,0,0,0, # bcd4_tr
    1,1,1,0,0,1, # regimen
    0,0,0,0,0,0) # incident_tb
  ,nrow=6,byrow=T)

K <- 15 # number of imputations

rsa.imp <- mice(data = data.to.impute_rsa,
               m = K,
               method=c("" #sex
                        ,"" #age
                        ,"pmm"  # bcd4_tr
                        ,"~I(sqrt(bcd4))"#bcd4_tr
                        ,"polyreg" #regimen
                        ,"" #incident_tb
                        )
                 ,predictorMatrix = pmat_rsa
                 ,seed=1569
                 ,maxit=20
                 )

# check imputations
summary(complete(rsa.imp, 0)) # with missingness, index 0
summary(complete(rsa.imp, 1)) # imputed index 1:K
```

## Fit model

```{r}
miceMCError <- function(pooledRes) {
  monteCarloSE <- sqrt(pooledRes$pooled$b/pooledRes$m)
  ciLower <- pooledRes$pooled$estimate - qt(0.975,df=pooledRes$m-1)*monteCarloSE
  ciUpper <- pooledRes$pooled$estimate + qt(0.975,df=pooledRes$m-1)*monteCarloSE
  mcTable <- cbind(pooledRes$pooled$estimate, monteCarloSE, ciLower, ciUpper)
  colnames(mcTable) <- c("Estimate", "Monte Carlo SE", "95% CI lower limit", "95% CI upper limit")
  print(mcTable)
  print("Warning: 95% CI only quantifies Monte-Carlo uncertainty!")
}
```

### Switzerland

```{r}
fit_ch_imp <- with(data = ch.imp, 
                  exp = glm(incident_tb ~ sex + age + who + regio + bcd4_tr + brna_tr,
                            family="binomial"))

pooled_ch <- pool(fit_ch_imp)
summary(pool(fit_ch_imp))
miceMCError(pooled_ch)
```

### South Africa

```{r}
fit_rsa_imp <- with(data = rsa.imp,
                    exp = glm(incident_tb ~ sex + age + bcd4_tr, 
                              family="binomial"))
pooled_rsa <- pool(fit_rsa_imp)
summary(pooled_rsa)
miceMCError(pooled_rsa)
```

## Time-varying

```{r}
cd4CH <- readRDS("../../data_clean/ch/cd4_ch.rds") %>% 
  mutate(cohort = "CH")

cd4CHuni <- cd4CH %>%
  distinct(id, .keep_all = TRUE) %>% 
  select(id, presenting_tb, cohort)

cd4RSA <- readRDS("../../data_clean/rsa/cd4_rsa.rds") %>% 
  mutate(cohort = "RSA")

cd4RSAuni <- cd4RSA %>%
  distinct(id, .keep_all = TRUE) %>% 
  select(id, presenting_tb, cohort)

cd4BOTH <- rbind(cd4CH %>% dplyr::select(-timepoint),
             cd4RSA %>% dplyr::select(-timepoint)) %>% 
  filter(time_diff >= -60 & time_diff < 420) %>% 
  mutate(cd4_trans = sqrt(cd4))

cd4BOTH %>% 
  ggplot(aes(x = time_diff, y = cd4_trans)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE)

```

Create the functions to calculate the median intervisit time per cohort and the grid.

```{r, intervisit}
intervisit_Md <- function(data) {
  
  result <- data %>%
    group_by(id) %>% 
    arrange(id, date_cd4) %>% 
    mutate(diff = date_cd4 - lag(date_cd4)) %>%
    filter(!is.na(diff)) %>% 
    ungroup() %>% 
    summarise(median_diff = median(diff, na.rm = TRUE)) %>% 
    as.numeric()
  
  return(result)
  
}

# Function to fill values into grid for each ID

fill_values_for_id <- function(patient_data, global_grid) {
  # Assuming 'cohort' and 'presenting_tb' are columns in patient_data
  cohort_val <- unique(patient_data$cohort)
  presenting_tb_val <- unique(patient_data$presenting_tb)

  results <- map_df(global_grid, function(grid_day) {
    interval_data <- patient_data %>%
      filter(time_diff >= grid_day & time_diff < grid_day + md_intvstCH)

    if (nrow(interval_data) > 0) {
      selected_measurement <- sample_n(interval_data, 1)
      tibble(days_since_ARTstart = grid_day, 
             cd4_value = selected_measurement$cd4, 
             cohort = cohort_val, 
             presenting_tb = presenting_tb_val)
    } else {
      tibble(days_since_ARTstart = grid_day, 
             cd4_value = NA_real_, 
             cohort = cohort_val, 
             presenting_tb = presenting_tb_val)
    }
  })

  return(results)
}

```

### Switzerland

```{r}
md_intvstCH <- intervisit_Md(cd4CH) # 4 months

# Create a global grid from 0 to 1080 days (3 years)
gridCH <- seq(from = 0, to = 1080, by = md_intvstCH)

gridCH_filled <- cd4CH %>%
  group_by(id) %>%
  group_modify(~fill_values_for_id(., gridCH)) %>%
  ungroup()

attach(gridCH_filled)
Y_CH <- data.frame(cd4_value)
X_CH <- data.frame(presenting_tb)
clus_CH <- data.frame(id)
# run jomo
class.imputed_CH <- jomo(Y = Y_CH, 
                      X = X_CH, 
                      clus = clus_CH, 
                      nburn = 1000, 
                      nbetween = 1000,
                      nimp = 5)

# use mitools package to fit data and apply Rubin's rules
# split imputations, and exclude original data (imputation "0")
imp.list_CH <- imputationList(split(class.imputed_CH, 
                                 class.imputed_CH$Imputation)[-1]) 


detach(gridCH_filled)
```

### South Africa

```{r}
md_intvstRSA <- intervisit_Md(cd4RSA) # 1 year

# Create a global grid from 0 to 1080 days (3 years)
gridRSA <- seq(from = 0, to = 1080, by = md_intvstRSA)

gridRSA_filled <- cd4RSA %>%
  group_by(id) %>%
  group_modify(~fill_values_for_id(., gridRSA)) %>%
  ungroup() 

attach(gridRSA_filled)
Y_RSA <- data.frame(cd4_value)
X_RSA <- data.frame(presenting_tb)
clus_RSA <- data.frame(id)
# run jomo
class.imputed_RSA <- jomo(Y = Y_RSA, 
                      X = X_RSA, 
                      clus = clus_RSA, 
                      nburn = 1000, 
                      nbetween = 1000,
                      nimp = 5)

detach(gridRSAfilled)
```

## Fit model 

The issue I see with my implementation: I impute the datasets seperately per cohort. 
At the same time I use cohort as fixed effect in the model i.e. i should feed the model the complete dataset.

```{r}
library(gamm4)

model_cd4_count <- gamm4(cd4_trans ~ cohort + presenting_tb +
                           s(time_diff, by = presenting_tb, bs = "cr", k = 4),
                                            random = ~ (1 | id),
                                            data = cd4)
```
